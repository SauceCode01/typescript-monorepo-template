// THIS FILE IS AUTO-GENERATED. DO NOT EDIT.
import { z } from "zod";

import * as api_archives_archiveId_DELETE from "./routes/archives/[archiveId]/DELETE";
import * as api_archives_archiveId_GET from "./routes/archives/[archiveId]/GET";
import * as api_archives_archiveId_PATCH from "./routes/archives/[archiveId]/PATCH";

import * as api_users_userId_GET from "./routes/users/[userId]/GET";
import { Request, RequestHandler, Response } from "express";

// this should be the final output.
// the data structure mirrors the route structure
// the structure is not final yet. it needs to be optimized to be more efficient and make all data about a route available under a single key
// this should be autogenerated and put on the dist folder along with the other file.
// it should be fully typed when consumed by other packages so make dx better.
// i should be able to inspect the type of the contract object and see all the types for each endpoint when consuming it on both client and server side.

export * from "./contract";

export const contracttt = {
  route_archives: {
    __path_segment: "/archives",
    route_param_archiveId: {
      __paramName: "archiveId",
      __pathSegment: "/:archiveId",
      DELETE: {
        __fullPath: "/archives/:archiveId",
        __method: "DELETE",
        request: {
          params: z.object({
            archiveId: z.string(),
          }),
          query: null,
          header: null,
          body: null,
        },
        responses: {
          200: z.object({
            status: z.string(),
            message: z.string(),
          }),
          500: z.object({
            message: z.string(),
          }),
        },
      },
      GET: null, // similar to delete, you need to follow what is in the schema
      PATCH: null, // similar to delete, you need to follow what is in the schema
    },
    GET: {},
    POST: {},
  },
  route_users: {
    __path_segment: "/users",
    route_param_userId: {
      __paramName: "userId",
      __pathSegment: "/:userId",
      GET: {},
    },
  },
  GET: {},
};

/**
 * how the contract definition is structured:
 * the contract will mirror the endpoint structure defined in src/routes, the route folder being the root of the contract.
 * endpoint is defined by a file inside a route folder with the HTTP method as the filename.ts extension.
 * each route folder can have subfolders for nested routes or parameterized routes.
 * each method file exports schema and metadata about the endpoint.
 * there needs to be a minimum require for each method file to be valid:
 * - all method files must export a "response" object that defines atleast the 200 status code. all other status codes can be added later. query, header, and body schema are optional depending on the method type.
 * - the "response" object must be a zod schema object with keys as status codes and values as zod schema defining the response body for that status code.
 * - for methods that use query parameters, a "query" export is required defining the zod schema for the query parameters.
 */

/**
 * usage for the backend implementation: 
 
import {RequestHandler} from "express";
import { createExpressController } from "@packages/contract-gen";

// createExpressController is a helper that will wrap your controller function
// with request parsing and response validation based on the contract
// it will throw error if request is invalid or if response does not match the schema
const controller : RequestHandler = createExpressController(
  contract, 
  "GET",
  "/archives/:archiveId",
  async (parsedRequest, sendResponse, req, res) => {
    // parsedRequest is fully typed and validated to mirror the schema
    // sendResponse is a helper function to send typed responses

    sendResponse(200, {
      status: "success",
      message: "Archive fetched successfully",
      data: {
        // ... archive data here
      }
    });
  }
)



*/

/**
 * usage for the client side callEndpoint: 

import { callEndpoint } from "@packages/api-typing";

// callEndpoint wraps fetch and provides typed request and response based on the contract
const response = await callEndpoint(
  "http://api.server.com", // base URL 
  "/archives/asdf-asdf-asdf-asdf", // endpoint path
  { 
    method: "GET", // HTTP method
    queryParams: { verbose: "true" }, // query params
    headers: { Authorization: "Bearer token" }, // headers
    body: null, // body for POST/PUT/PATCH
  }
);

// response will be fully typed based on the contract
if (response.status === 200) {
  console.log("Archive data:", response.body.data);
} else {
  console.error("Error:", response.body.message);
}

 */

interface testing {
  a: string;
  b: number;
}

export type Type<T extends keyof testing> = testing[T];

const key = "b";
const value: Type<typeof key> = 1; // value is of type string

type inferRequest<T> = T;
type inferResponse<T> = T;

type inferRequestHandler<T> = ({
  request,
  response,
  ctx,
}: {
  request: inferRequest<T>;
  response: inferResponse<T>;
  ctx: {
    req: Request;
    res: Response;
  };
}) => Promise<inferResponse<T>>;

export const createExpressController = <T>(
  contract: T,
  handler: inferRequestHandler<T>
) => {};
