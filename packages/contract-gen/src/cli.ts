#!/usr/bin/env -S npx tsx

import { Command } from "commander";
import fs from "fs";
import path from "path";

const program = new Command();

program
  .name("contract-gen")
  .description("Generates a single Zod contract object from a file-based API structure")
  .requiredOption("-i, --input <path>", "Input directory containing route files")
  .requiredOption("-o, --output <path>", "Output file path (e.g., src/index.ts)")
  .parse(process.argv);

const options = program.opts();
const INPUT_DIR = path.resolve(process.cwd(), options.input);
const OUTPUT_FILE = path.resolve(process.cwd(), options.output);

// Helper: Check if folder is a param (e.g. [userId])
const isParam = (name: string) => name.startsWith("[") && name.endsWith("]");

function generate() {
  if (!fs.existsSync(INPUT_DIR)) {
    console.error(`❌ Input directory not found: ${INPUT_DIR}`);
    process.exit(1);
  }

  const imports: string[] = [];
  const structure: any = {};

  function walk(currentDir: string, currentMap: any, pathStack: string[]) {
    const items = fs.readdirSync(currentDir);

    for (const item of items) {
      const fullPath = path.join(currentDir, item);
      const stat = fs.statSync(fullPath);

      if (stat.isDirectory()) {
        const key = isParam(item) ? `sw_param_${item.slice(1, -1)}` : item;
        currentMap[key] = currentMap[key] || {};

        if (isParam(item)) {
          currentMap[key]["__paramName"] = item.slice(1, -1);
        }

        walk(fullPath, currentMap[key], [...pathStack, item]);
      } else if (item.endsWith(".ts") || item.endsWith(".tsx")) {
        const method = item.replace(/\.tsx?$/, ""); // GET, POST
        
        // 1. Generate unique variable name for import
        const safePath = pathStack.map(s => s.replace(/\[|\]/g, '')).join('_');
        const importName = `route_${safePath}_${method}`;

        // 2. Calculate relative path from OUTPUT_FILE location to the ROUTE file
        const outputDir = path.dirname(OUTPUT_FILE);
        let relativePath = path.relative(outputDir, fullPath);
        
        // --- FIX STARTS HERE ---
        // Normalize path separators to forward slashes (/) for imports
        // This handles Windows paths (e.g., ..\api\file) correctly
        relativePath = relativePath.split(path.sep).join("/");
        // --- FIX ENDS HERE ---

        // Ensure relative path starts with "./" or "../"
        if (!relativePath.startsWith(".")) {
          relativePath = "./" + relativePath;
        }
        
        // Remove extension for import
        relativePath = relativePath.replace(/\.tsx?$/, "");

        imports.push(`import * as ${importName} from "${relativePath}";`);

        const pathParams = pathStack.filter(isParam).map((p) => p.slice(1, -1));

        currentMap[method] = `__CODE_START__${importName}__CODE_END__`;
        currentMap[`${method}_params`] = pathParams;
      }
    }
  }

  walk(INPUT_DIR, structure, []);

  // Serialize and unwrap
  let jsonString = JSON.stringify(structure, null, 2);
  jsonString = jsonString.replace(/"__CODE_START__(.*?)__CODE_END__"/g, "$1");

  const fileContent = `
// --------------------------------------------------------------------------
// ⚠️ THIS FILE IS AUTO-GENERATED BY @repo/contract-gen. DO NOT EDIT.
// --------------------------------------------------------------------------
import { z } from 'zod';

${imports.join("\n")}

export const contract = ${jsonString} as const;
`;

  // Ensure output dir exists
  fs.mkdirSync(path.dirname(OUTPUT_FILE), { recursive: true });
  fs.writeFileSync(OUTPUT_FILE, fileContent);
  
  console.log(`✅ Contract generated at: ${options.output}`);
}

generate();